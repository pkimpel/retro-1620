<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>retro-1620 1627 Plotter POC-4</title>
<!--
/***********************************************************************
* retro-1620/Misc Plotter-POC-4.html
************************************************************************
* Copyright (c) 2023, Paul Kimpel.
* Licensed under the MIT License, see
*       http://www.opensource.org/licenses/mit-license.php
************************************************************************
* IBM 1627 plotter proof-of-concept page.
* Version of Bresenham's line algorithm adapted from the example based
* on reference [2] at
* https://en.wikipedia.org/wiki/Bresenham%27s_line_algorithm.
************************************************************************
* 2023-12-17  P.Kimpel
*   Original version.
***********************************************************************/
-->
<meta name="Author" content="Paul Kimpel">
<meta http-equiv="Content-Script-Type" content="text/javascript">
<meta http-equiv="Content-Style-Type" content="text/css">
<!--
<link id=defaultStyleSheet rel=stylesheet type="text/css" href="./Common.css">
<link id=supervisoryStyleSheet rel=stylesheet type="text/css" href="./ControlPanel.css">
-->

<style>
#PlotterDiv {
    position:           relative;
    width:              578px;
    height:             480px;
    overflow:           scroll;
    background-color:   white;
    border:             1px solid black;
    box-shadow:         6px 6px 6px #333}
#PlotterCanvas {
    margin:             4px;
    border:             1px dotted black}
</style>

<script>
window.addEventListener("load", async (ev) => {
    const canvas = this.document.getElementById("PlotterCanvas");
    const container = this.document.getElementById("PlotterDiv");
    const containerRect = container.getBoundingClientRect();
    const dc = canvas.getContext("2d");

    const canvasMaxSize =               32764;          // pixels (for Firefox in 2023)
    const canvasStepSize =              0.01;           // inch
    const canvasWidth =                 11;             // inch
    const canvasPixelWidth =            canvasWidth/canvasStepSize;
    const canvasScaleFactor =           (containerRect.width-8-20)/canvasPixelWidth;
    const canvasHeight =                canvasMaxSize*canvasStepSize/canvasScaleFactor; // inch (about 54 feet)
    const canvasPixelHeight =           canvasHeight/canvasStepSize;
    const canvasLineWidth =             1/canvasScaleFactor;
    const canvasOffsetX =               0.5/canvasScaleFactor;
    const canvasOffsetY =               0.5/canvasScaleFactor;
    const stepPeriod =                  1000/300;       // milliseconds, 1627 Model 1
    const minWait =                     8;              // milliseconds

    let lastx = 0;
    let lasty = 0;
    let pendingWait = 0;

    canvas.height = canvasPixelHeight*canvasScaleFactor;
    canvas.width = canvasPixelWidth*canvasScaleFactor;

    function toCanvasCoord(x, y) {
        /* Converts transformed canvas unit coordinates into canvas (pixel)
        coordinates */

        return [(x-canvasOffsetX)*canvasScaleFactor, (y-canvasOffsetY)*canvasScaleFactor];
    }

    function delay(period) {
        pendingWait += period;
        if (pendingWait < minWait) {
            return Promise.resolve();
        } else {
            return new Promise((resolve, reject) => {
                setTimeout(resolve, pendingWait);
                pendingWait = 0;
            });
        }
    }

    async function drawCursor(x, y) {
        const [px, py] = toCanvasCoord(x, y);
        const savePix = dc.getImageData(py-4, px-4, 8, 8);

        dc.save();
        dc.strokeStyle = "gray";
        dc.beginPath();
        dc.arc(y, x, 3, Math.PI*2, false);
        dc.stroke();
        dc.restore();
        await delay(stepPeriod);
        dc.putImageData(savePix, py-4, px-4);
    }

    // Bresenham's algorithm.
    async function moveTo(x, y) {
        if (x != lastx || y != lasty) {
            await plotLine(lastx, lasty, x, y, null);
        }
    }

    async function plotLine(x0, y0, x1, y1, color) {
        const dx = Math.abs(x1 - x0);
        const dy = -Math.abs(y1 - y0);
        const incx = (x0 < x1 ? 1 : -1);
        const incy = (y0 < y1 ? 1 : -1);
        let err = dx + dy;
        let x = x0;
        let y = y0;

        if (color) {
            await moveTo(x0, y0);
            dc.fillStyle = color;
        }

        for (;;) {
            if (color) {
                dc.fillRect(y, x, canvasLineWidth, canvasLineWidth);
                await delay(stepPeriod);
            } else {
                await drawCursor(x, y);
            }

            const e2 = 2*err;
            if (e2 >= dy) {
                if (x == x1) {
                    break;
                } else {
                    err += dy;
                    x += incx;
                }
            }

            if (e2 <= dx) {
                if (y == y1) {
                    break;
                } else {
                    err += dx;
                    y += incy;
                }
            }
        }

        lastx = x;
        lasty = y;
    }

    dc.save();
    dc.scale(canvasScaleFactor, canvasScaleFactor);
    dc.translate(canvasScaleFactor/2, canvasScaleFactor/2);
    dc.fillStyle = "transparent";       // fill in the panel background (aids antialiasing)
    dc.strokeStyle = "black";
    dc.lineWidth = canvasLineWidth;
    dc.clearRect(0, 0, canvasPixelWidth, canvasPixelHeight);

    let left = 50;
    let right = 750;
    let top = 200;
    let bottom = 900;

    while (right-left >= 0) {
        await plotLine(left, top, right, top, "black");
        await plotLine(right, top, right, bottom, "black");
        await plotLine(right, bottom, left, bottom, "black");
        await plotLine(left, bottom, left, top, "black");
        left += 50;
        right -= 50;
        top += 50;
        bottom -= 50;
    }

    await plotLine(700,50, 1000,300, "red");
    await plotLine(1000,300, 800,500, "blue");
    await plotLine(800,500, 1200,200, "green");
    await plotLine(1200,200, 700,1000, "orange");

    dc.restore();
    alert("Done");
}, {once:true});
</script>

</head>

<body class=panelBody>
<p><strong>retro-1620 1627 Plotter Proof-of-Concept 4</stong></p>

<div id=PlotterDiv>
        <canvas id=PlotterCanvas>
            This browser does not support the HTML &lt;canvas&gt; element.
        </canvas>
</div>

</body>
</html>