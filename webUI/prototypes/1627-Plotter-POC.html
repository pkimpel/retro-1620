<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>retro-1620 1627 Plotter POC-2</title>
<!--
/***********************************************************************
* retro-1620/Misc Plotter-POC-2.html
************************************************************************
* Copyright (c) 2023, Paul Kimpel.
* Licensed under the MIT License, see
*       http://www.opensource.org/licenses/mit-license.php
************************************************************************
* IBM 1627 plotter proof-of-concept page.
************************************************************************
* 2023-12-17  P.Kimpel
*   Original version.
***********************************************************************/
-->
<meta name="Author" content="Paul Kimpel">
<meta http-equiv="Content-Script-Type" content="text/javascript">
<meta http-equiv="Content-Style-Type" content="text/css">
<!--
<link id=defaultStyleSheet rel=stylesheet type="text/css" href="./Common.css">
<link id=supervisoryStyleSheet rel=stylesheet type="text/css" href="./ControlPanel.css">
-->

<style>
#PlotterDiv {
    position:           relative;
    width:              578px;
    height:             480px;
    overflow:           scroll;
    background-color:   white;
    border:             1px solid black;
    box-shadow:         6px 6px 6px #333}

#PlotterCanvas {
    margin:             4px;
    border:             1px dotted black}
</style>

<script>
window.addEventListener("load", async (ev) => {
    const canvas = this.document.getElementById("PlotterCanvas");
    const container = this.document.getElementById("PlotterDiv");
    const clientRect = container.getBoundingClientRect();
    const dc = canvas.getContext("2d");

    const canvasMaxSize =               32764;          // pixels (for Firefox in 2023)
    const canvasStepSize =              0.01;           // inch
    const canvasWidth =                 11;             // inch
    const canvasPixelWidth =            canvasWidth/canvasStepSize;
    const canvasScaleFactor =           (clientRect.width-8-20)/canvasPixelWidth;
    const canvasHeight =                canvasMaxSize*canvasStepSize/canvasScaleFactor; // inch (about 54 feet)
    const canvasPixelHeight =           canvasHeight/canvasStepSize;
    const lineWidth =                   1/canvasScaleFactor;
    const stepPeriod =                  1000/300;       // milliseconds, 1627 Model 1
    const minWait =                     4;              // milliseconds

    let lastx = 0;
    let lasty = 0;
    let pendingWait = 0;

    canvas.height = canvasPixelHeight*canvasScaleFactor;
    canvas.width = canvasPixelWidth*canvasScaleFactor;

    const delay = (period) => {
        pendingWait += period;
        if (pendingWait > minWait) {
            return new Promise((resolve, reject) => {
                setTimeout(resolve, pendingWait);
                pendingWait = 0;
            });
        } else {
            return Promise.resolve();
        }
    };

    // Bresenham's algorithm.
    const moveTo = async (x, y) => {
        await plotLine(lastx, lasty, x, y, null);
    };

    const plotLine = async (x0, y0, x1, y1, color) => {
        const dx = x1 - x0;
        const dy = y1 - y0;
        const incx = (dx < 0 ? -1 : 1);
        const incy = (dy < 0 ? -1 : 1);
        let D = 2*dy - dx;
        let y = y0;

        if (color) {
            await moveTo(x0, y0);
            dc.fillStyle = color;
        }

        for (let x=x0; x<=x1; ++x) {
            await delay(stepPeriod);
            if (color) {
                dc.fillRect(y, x, lineWidth, lineWidth);
            }

            if (D > 0) {
                y += 1;
                D -= 2*dx;
            }

            lastx = x;
            lasty = y;
            D += 2*dy;
        }
    };


    dc.save();
    dc.scale(canvasScaleFactor, canvasScaleFactor);
    dc.translate(canvasScaleFactor/2, canvasScaleFactor/2);
    dc.fillStyle = "transparent";       // fill in the panel background (aids antialiasing)
    dc.strokeStyle = "black";
    dc.lineWidth = lineWidth;
    dc.lineJoin = "round";
    dc.clearRect(0, 0, canvasPixelWidth, canvasPixelHeight);

    await plotLine(25,50, 200,300, "red");
    await plotLine(200,300, 500,500, "blue");
    await plotLine(500,500, 400,200, "green");
    await plotLine(400,200, 333,1000, "black");

    await plotLine(100,100, 100,500, "orange");
    await plotLine(100,500, 500,500, "orange");
    await plotLine(500,500, 500,100, "orange");
    await plotLine(500,100, 100,100, "orange");

    dc.restore();
    alert("Done");
}, {once:true});
</script>

</head>

<body class=panelBody>
<p><strong>retro-1620 1627 Plotter Proof-of-Concept 2</stong></p>

<div id=PlotterDiv>
    <canvas id=PlotterCanvas>
        This browser does not support the HTML &lt;canvas&gt; element.
    </canvas>
</div>

</body>
</html>