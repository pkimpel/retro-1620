<!DOCTYPE html>
<html>
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <title>Build I/O Translator Tables</title>
<!--
/***********************************************************************
* retro-1620/software Xlate-Gen.html
************************************************************************
* Copyright (c) 2024, Paul Kimpel.
* Licensed under the MIT License, see
*       http://www.opensource.org/licenses/mit-license.php
************************************************************************
* IBM 1620 test page to generate complete Input/Output Translator results
* from the logic in Drawings 10.01.90.1, 10.01.91.1, 10.01.95.1, and
* 10.01.96.1 of the Model 2 ILD manual.
* See http://bitsavers.org/pdf/ibm/1620/fe/227-5857-0_1620_Model_2_Customer_Engineering_Intermediate_Level_Diagrams_Apr64.pdf.
************************************************************************
* 2024-05-30  P.Kimpel
*   Original version.
***********************************************************************/
-->
    <meta name="Author" content="Paul Kimpel">

<style>
BODY {
    font-family:        Arial, Helvetica, sans serif;
    font-size:          9pt}
TABLE {
    border-collapse:    collapse;
    border-spacing:     0}
#XlateBody TD {
    font-family:        DejaVu Sans Mono, Consolas, monospace;
    font-size:          9pt;
    text-align:         right}
.glyph {
    font-weight:        bold;
    color:              #008;
    text-align:         center}
.parityIn {
    background-color:   #CCC}
.parityErr {
    color:              red}
.center {
    text-align:         center}
.gray {
    background-color:   gray}
</style>

<script>


window.addEventListener("load", (ev) => {
    const bcdMask  = 0b0001111;

    const oddParity5 = [
        0b100000, 0b000001, 0b000010, 0b100011, 0b000100, 0b100101, 0b100110, 0b000111,     // 0-7
        0b001000, 0b101001, 0b101010, 0b001011, 0b101100, 0b001101, 0b001110, 0b101111,     // 8-15
        0b010000, 0b110001, 0b110010, 0b010011, 0b110100, 0b010101, 0b010110, 0b110111,     // 16-23
        0b111000, 0b011001, 0b011010, 0b111011, 0b011100, 0b111101, 0b111110, 0b011111,     // 24-31
        0b100000, 0b000001, 0b000010, 0b100011, 0b000100, 0b100101, 0b100110, 0b000111,     // 32-30
        0b001000, 0b101001, 0b101010, 0b001011, 0b101100, 0b001101, 0b001110, 0b101111,     // 40-47
        0b010000, 0b110001, 0b110010, 0b010011, 0b110100, 0b010101, 0b010110, 0b110111,     // 48-55
        0b111000, 0b011001, 0b011010, 0b111011, 0b011100, 0b111101, 0b111110, 0b011111];    // 56-63

    // Translate memory digit pairs to 1620 character glyphs
    const alphaGlyphs = [       // indexed as (even digit BCD)*16 + (odd digit BCD)
        " ", "_", "_", ".", ")", "_", "_", "_", "_", "_", "|", "_", "_", "_", "_", "}",         // 00-0F
        "+", "_", "_", "$", "*", "_", "_", "_", "_", "_", "_", "_", "_", "_", "_", "_",         // 10-1F
        "-", "/", "_", ",", "(", "_", "^", "_", "_", "_", "_", "_", "_", "_", "_", "_",         // 20-2F
        "_", "_", "_", "=", "@", "_", "_", "_", "_", "_", "_", "_", "_", "_", "_", "_",         // 30-3F
        "_", "A", "B", "C", "D", "E", "F", "G", "H", "I", "_", "_", "_", "_", "_", "_",         // 40-4F
        "]", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "!", "_", "_", "_", "_", "\"",        // 50-5F
        "_", "_", "S", "T", "U", "V", "W", "X", "Y", "Z", "_", "_", "_", "_", "_", "_",         // 60-6F
        "0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "_", "_", "_", "_", "_", "_",         // 70-7F
        "_", "_", "_", "_", "_", "_", "_", "_", "_", "_", "_", "_", "_", "_", "_", "_",         // 80-8F
        "_", "_", "_", "_", "_", "_", "_", "_", "_", "_", "_", "_", "_", "_", "_", "_",         // 90-9F
        "_", "_", "_", "_", "_", "_", "_", "_", "_", "_", "_", "_", "_", "_", "_", "_",         // A0-AF
        "_", "_", "_", "_", "_", "_", "_", "_", "_", "_", "_", "_", "_", "_", "_", "_",         // B0-BF
        "_", "_", "_", "_", "_", "_", "_", "_", "_", "_", "_", "_", "_", "_", "_", "_",         // C0-CF
        "_", "_", "_", "_", "_", "_", "_", "_", "_", "_", "_", "_", "_", "_", "_", "_",         // D0-DF
        "_", "_", "_", "_", "_", "_", "_", "_", "_", "_", "_", "_", "_", "_", "_", "_",         // E0-EF
        "_", "_", "_", "_", "_", "_", "_", "_", "_", "_", "_", "_", "_", "_", "_", "_"];        // F0-FF

    const xlateASCIIToPTCode = {        // ASCII to 1620 paper-tape punch bits
           //  EX0C8421 tape channels
        "0": 0b00100000,
        "1": 0b00000001,
        "2": 0b00000010,
        "3": 0b00010011,
        "4": 0b00000100,
        "5": 0b00010101,
        "6": 0b00010110,
        "7": 0b00000111,
        "8": 0b00001000,
        "9": 0b00011001,
        "A": 0b01100001,
        "B": 0b01100010,
        "C": 0b01110011,
        "D": 0b01100100,
        "E": 0b01110101,
        "F": 0b01110110,
        "G": 0b01100111,
        "H": 0b01101000,
        "I": 0b01111001,
        "]": 0b01000000,        // -0 (flagged 0)
        "J": 0b01010001,
        "K": 0b01010010,
        "L": 0b01000011,
        "M": 0b01010100,
        "N": 0b01000101,
        "O": 0b01000110,
        "P": 0b01010111,
        "Q": 0b01011000,
        "R": 0b01001001,
        "S": 0b00110010,
        "T": 0b00100011,
        "U": 0b00110100,
        "V": 0b00100101,
        "W": 0b00100110,
        "X": 0b00110111,
        "Y": 0b00111000,
        "Z": 0b00101001,
        ".": 0b01101011,
        ")": 0b01111100,
        "*": 0b01001100,
        "$": 0b01011011,
        "(": 0b00101100,
        ",": 0b00111011,
        "|": 0b00101010,        // Record Mark
        "!": 0b01001010,        // flagged Record Mark
        "=": 0b00001011,
        "@": 0b00011100,
        "+": 0b01110000,
        "-": 0b01000000,
        " ": 0b00010000,
        "/": 0b00110001,
        "^": 0b00111110,        // "special" char
        "}": 0b00101111,        // Group Mark
        "\"":0b01001111,        // flagged Group Mark
    };

    const ptCodeGlyphs = Array(256);


    function xlateIn(code, selector, op) {
        /* Translates the paper-tape-like "code" to 1620 internal memory code
        for the I/O device indicated by "selector" and input mode indicated by
        opcode "op" */
        const readAlpha = (op == 37 ? 1 : 0);           // read alphanumeric op
        const readNumeric = (op == 36 ? 1 : 0);         // read numeric op
        const readBinary = (selector == 33 ? 1 : 0) & readAlpha; // read binary mode

        // Input paper-tape code bit numbers.
        const b1 = (code & 0b00000001);                 // 1-bit channel
        const b2 = (code & 0b00000010) >> 1;            // 2-bit channel
        const b4 = (code & 0b00000100) >> 2;            // 4-bit channel
        const b8 = (code & 0b00001000) >> 3;            // 8-bit channel    (also readBinary zone 1)
        const bc = (code & 0b00010000) >> 4;            // check-bit channel
        const b0 = (code & 0b00100000) >> 5;            // zero-bit channel (also readBinary zone 2)
        const bx = (code & 0b01000000) >> 6;            // X-bit channel    (also readBinary zone 4)
        const be = (code & 0b10000000) >> 7;            // EOL channel

        // readBinary zone bit equivalents.
        const bz1 = readBinary & b8;
        const bz2 = readBinary & b0;
        const bz4 = readBinary & bx;

        const tEndLinePT = (selector == 3 ? be : 0);    // ??
        const tBlank = (code == 0b00010000 ? 1 : 0);
        const t1622Bit0NotFlgGM = (code == 0b01111111 ? 0 : b0);
        const tInOutPlusSign = 0;                       // ?? 1711 ??

        // Read bus numeric bits.
        const rb1 = b1;
        const rb2 = b2 | tEndLinePT;
        const rb4 = b4;
        const rb8 = b8 | tEndLinePT;

        // Read bus zone bits.
        const rb0 = (selector == 5 ? t1622Bit0NotFlgGM : b0) | tEndLinePT;
        const rbx = bx;
        const rbc = tBlank | bc | tInOutPlusSign;

        // Output readNumeric bits.
        const t83Not4 = rb8 & rb2 & rb1 & ~rb4;
        const tRMGM = t83Not4 & rb2 & rb8;
        const tNot841 = ~(tRMGM & rb1 & rb4 & rb8 & ~readBinary);       // added negation

        const n1 = (rb1 & tNot841) & 1;

        const n2 = (rb2) & 1;

        const n4 = (rb4 & tNot841) & 1;

        const n8 = (((rb8 & ~rb4 & ~rb2) | tRMGM | (rb8 & tNot841 & readNumeric)) & ~readBinary) & 1;

        const t841 = rb8 & rb4 & rb1;
        const t84Not1 = rb8 & rb4 & ~rb1;
        const tCorrCBit = (~rb0 & rbx) | (rb0 & ~rbx);
        const tNCa = ((rbc & tCorrCBit) | (~rbc & ~tCorrCBit)) & ~tBlank;

        const nc = ((tNCa | (tNCa & t84Not1 & readAlpha) | (tNCa & readNumeric) | t841 |
                                (readAlpha & t83Not4)) &
                        ~readBinary & (selector == 7 ? 0 : 1)) & 1;


        const tNum0 = b1 | b2 | b4 | b8;
        const tSpecChar = (rb1 & rb2 & rb8) | t84Not1;
        const tRdBus0RM = rb0 & tRMGM;                  // ??
        const tZ2a = (~rbx & tNum0 & ~rb0) & ~rbx & ~tRMGM & ~readBinary;

        const ioFlag = (rbx & (!tRMGM & !tNum0) & readNumeric);

        // Output zone bits.
        const z1 = (((rb0 & ~tNum0) & (tNum0 & ~rb0) & ~readBinary & ~tRMGM) | bz1) & 1;
        const z2 = (tZ2a | bz2 | (~readBinary & tNum0 & ~rb0 & rbx)) & 1;
        const z4 = (((tNum0 & tZ2a) & ~tRdBus0RM & ~readBinary & ~b1 & ~tSpecChar & ~tRMGM) | bz4) & 1;
        const zc = ((~((~tSpecChar & tCorrCBit) | (tSpecChar & ~tCorrCBit)) & ~rb1 & ~tNum0) |
                        tBlank | tRdBus0RM | bz1) & 1;

        return [(((((((((zc << 1) |      0) << 1) |  0) << 1) | z4) << 1) | z2) << 1) | z1,
                (((((((((nc << 1) | ioFlag) << 1) | n8) << 1) | n4) << 1) | n2) << 1) | n1];
    }

    function formatOddParity5(n) {
        const e = document.createElement("span");
        e.textContent = n.toString(2).padStart(6, "0");
        if (oddParity5[n] != n) {
            e.classList.add("parityErr");
        }

        return e;
    }

    function formatOddParity8(n) {
        const e = document.createElement("span");
        e.textContent = n.toString(2).padStart(8, "0");
        const p = ~(oddParity5[(n >> 5) & 0x7] ^ oddParity5[n & 0xF]);
        if (((p & 0b100000) >> 5) != ((n & 0b00010000) >> 4)) {
            e.classList.add("parityErr");
        }

        return e;
    }

    function formatXlate(row, zone, num) {
        /*  */
        let cell = document.createElement("td");
        cell.appendChild(formatOddParity5(zone));
        cell.appendChild(document.createTextNode(" "));
        cell.appendChild(formatOddParity5(num));
        row.appendChild(cell);

        cell = document.createElement("td");
        cell.classList.add("glyph");
        cell.textContent = alphaGlyphs[(zone & bcdMask)*16 + (num & bcdMask)];
        row.appendChild(cell);
    }

    /**********************************/
    const body = document.getElementById("XlateBody");

    // Build the ptCodeGlyphs array;
    ptCodeGlyphs.fill("_");
    for (let glyph in xlateASCIIToPTCode) {
        ptCodeGlyphs[xlateASCIIToPTCode[glyph]] = glyph;
    }

    // Generate input translation.
    for (let code=0; code<256; ++code) {
        const row = document.createElement("tr");

        let cell = document.createElement("td");
        let e = formatOddParity8(code);
        cell.appendChild(e);
        row.appendChild(cell);
        if (e.classList.contains("parityErr")) {
            row.classList.add("gray");
        }

        cell = document.createElement("td");
        cell.classList.add("glyph");
        cell.appendChild(document.createTextNode(ptCodeGlyphs[code].replace(" ", "\xA0")));
        row.appendChild(cell);

       let [zone, num] = xlateIn(code, 3, 36);
       formatXlate(row, zone, num);

       [zone, num] = xlateIn(code, 3, 37);
       formatXlate(row, zone, num);

       [zone, num] = xlateIn(code, 33, 37);
        cell = document.createElement("td");
        cell.appendChild(formatOddParity5(zone));
        cell.appendChild(document.createTextNode(" "));
        cell.appendChild(formatOddParity5(num));
        row.appendChild(cell);

        cell = document.createElement("td");
        cell.classList.add("glyph");
        cell.textContent = (zone & bcdMask).toString(16) + (num & bcdMask).toString(16);
        row.appendChild(cell);

       [zone, num] = xlateIn(code, 5, 36);
       formatXlate(row, zone, num);

       [zone, num] = xlateIn(code, 5, 37);
       formatXlate(row, zone, num);

        body.appendChild(row);
    }

    /***********************************
    // Dump the add table results.
    const resultsPre = document.getElementById("AddResults");
    resultsPre.appendChild(document.createTextNode("const addTable = [\n"));
    for (let p=0; p<32; ++p) {
        let line = "    [";
        for (let q=0; q<32; ++q) {
            line += "0x" + sumTable[p][q].toString(16).padStart(2, "0") + ",";
        }

        resultsPre.appendChild(document.createTextNode(line.slice(0, -1) + "],\n"));
    }

    resultsPre.appendChild(document.createTextNode("];\n"));
    ***********************************/
}, {once: true});
</script>
</head>

<body>
<h2>Build Full Xlate Table</h2>
<table border=1 cellspacing=0 cellpadding=2>
    <thead>
        <tr>
            <th rowspan=2 colspan=2>Code
            <th colspan=6>PaperTape
            <th colspan=4>Card
        <tr>
            <th colspan=2>Numeric
            <th colspan=2>Alpha
            <th colspan=2>Binary
            <th colspan=2>Numeric
            <th colspan=2>Alpha
    <tbody id=XlateBody>
</table>
<h2>Translator Table Results</h2>
<pre id=XlateResults></pre>

</body>
</html>