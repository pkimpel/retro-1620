<!DOCTYPE html>
<html>
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <title>Build I/O Translator Tables</title>
<!--
/***********************************************************************
* retro-1620/software Xlate-Gen.html
************************************************************************
* Copyright (c) 2024, Paul Kimpel.
* Licensed under the MIT License, see
*       http://www.opensource.org/licenses/mit-license.php
************************************************************************
* IBM 1620 test page to generate complete Input/Output Translator results
* from the logic in Drawings 10.01.90.1, 10.01.91.1, 10.01.95.1, and
* 10.01.96.1 of the Model 2 ILD manual.
* See http://bitsavers.org/pdf/ibm/1620/fe/227-5857-0_1620_Model_2_Customer_Engineering_Intermediate_Level_Diagrams_Apr64.pdf.
************************************************************************
* 2024-05-30  P.Kimpel
*   Original version.
***********************************************************************/
-->
    <meta name="Author" content="Paul Kimpel">

<style>
BODY {
    font-family:        Arial, Helvetica, sans serif;
    font-size:          8pt}
TABLE {
    border-collapse:    collapse;
    border-spacing:     0}
#XlateBody TD {
    font-family:        DejaVu Sans Mono, Consolas, monospace;
    font-size:          8pt;
    text-align:         right}
#XlateBody TR TD.rowNrCell {
    font-family:        Arial, Helvetica, sans serif;
    font-size:          8pt;
    font-weight:        bold;
    text-align:         center}
.base10 {
    background-color:   #CFC;
    border:             2px solid black}
.parityIn {
    background-color:   #CCC}
.parityOut {
    color:              red}
</style>

<script>


window.addEventListener("load", (ev) => {
    const bcdMask  = 0b0001111;

    const oddParity5 = [
        0b100000, 0b000001, 0b000010, 0b100011, 0b000100, 0b100101, 0b100110, 0b000111,     // 0-7
        0b001000, 0b101001, 0b101010, 0b001011, 0b101100, 0b001101, 0b001110, 0b101111,     // 8-15
        0b010000, 0b110001, 0b110010, 0b010011, 0b110100, 0b010101, 0b010110, 0b110111,     // 16-23
        0b111000, 0b011001, 0b011010, 0b111011, 0b011100, 0b111101, 0b111110, 0b011111,     // 24-31
        0b100000, 0b000001, 0b000010, 0b100011, 0b000100, 0b100101, 0b100110, 0b000111,     // 32-30
        0b001000, 0b101001, 0b101010, 0b001011, 0b101100, 0b001101, 0b001110, 0b101111,     // 40-47
        0b010000, 0b110001, 0b110010, 0b010011, 0b110100, 0b010101, 0b010110, 0b110111,     // 48-55
        0b111000, 0b011001, 0b011010, 0b111011, 0b011100, 0b111101, 0b111110, 0b011111];    // 56-63

    // Translate memory digit pairs to 1620 character glyphs
    const alphaGlyphs = [       // indexed as (even digit BCD)*16 + (odd digit BCD)
        " ", "_", "_", ".", ")", "_", "_", "_", "_", "_", "|", "_", "_", "_", "_", "}",         // 00-0F
        "+", "_", "_", "$", "*", "_", "_", "_", "_", "_", "_", "_", "_", "_", "_", "_",         // 10-1F
        "-", "/", "_", ",", "(", "_", "^", "_", "_", "_", "_", "_", "_", "_", "_", "_",         // 20-2F
        "_", "_", "_", "=", "@", "_", "_", "_", "_", "_", "_", "_", "_", "_", "_", "_",         // 30-3F
        "_", "A", "B", "C", "D", "E", "F", "G", "H", "I", "_", "_", "_", "_", "_", "_",         // 40-4F
        "]", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "!", "_", "_", "_", "_", "\"",        // 50-5F
        "_", "_", "S", "T", "U", "V", "W", "X", "Y", "Z", "_", "_", "_", "_", "_", "_",         // 60-6F
        "0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "_", "_", "_", "_", "_", "_",         // 70-7F
        "_", "_", "_", "_", "_", "_", "_", "_", "_", "_", "_", "_", "_", "_", "_", "_",         // 80-8F
        "_", "_", "_", "_", "_", "_", "_", "_", "_", "_", "_", "_", "_", "_", "_", "_",         // 90-9F
        "_", "_", "_", "_", "_", "_", "_", "_", "_", "_", "_", "_", "_", "_", "_", "_",         // A0-AF
        "_", "_", "_", "_", "_", "_", "_", "_", "_", "_", "_", "_", "_", "_", "_", "_",         // B0-BF
        "_", "_", "_", "_", "_", "_", "_", "_", "_", "_", "_", "_", "_", "_", "_", "_",         // C0-CF
        "_", "_", "_", "_", "_", "_", "_", "_", "_", "_", "_", "_", "_", "_", "_", "_",         // D0-DF
        "_", "_", "_", "_", "_", "_", "_", "_", "_", "_", "_", "_", "_", "_", "_", "_",         // E0-EF
        "_", "_", "_", "_", "_", "_", "_", "_", "_", "_", "_", "_", "_", "_", "_", "_"];        // F0-FF

    function xlateIn(code, selector, op) {
        /* Translates the paper-tape-like "code" to 1620 internal memory code
        for the I/O device indicated by "selector" and input mode indicated by
        opcode "op" */
        const alpha = (op == 37 ? 1 : 0);               // read alpha op
        const numeric = (op == 36 ? 1 : 0);             // read numeric op
        const binary = (selector == 33 ? 1 : 0) & alpha;// read binary mode

        // Input code bit numbers.
        const b1 = (code & 0b00000001);                 // 1-bit channel
        const b2 = (code & 0b00000010) >> 1;            // 2-bit channel
        const b4 = (code & 0b00000100) >> 2;            // 4-bit channel
        const b8 = (code & 0b00001000) >> 3;            // 8-bit channel    (also binary zone 1)
        const bc = (code & 0b00010000) >> 4;            // check-bit channel
        const b0 = (code & 0b00100000) >> 5;            // zero-bit channel (also binary zone 2)
        const bx = (code & 0b01000000) >> 6;            // X-bit channel    (also binary zone 4)
        const be = (code & 0b10000000) >> 7;            // EOL channel

        // Binary zone bit equivalents.
        const bz1 = binary & bc;
        const bz2 = binary & b0;
        const bz4 = binary & bx;

        const tEndLinePT = (selector == 3 ? be : 0);    // ??

        // Read bus numeric bits.
        const rb1 = b1;
        const rb2 = b1 | tEndLinePT;
        const rb4 = b4;
        const rb8 = b8 | tEndLinePT;

        const t83Not4 = rb8 & rb2 & rb1 & ~rb4;
        const t841 = rb8 & rb4 & rb1;
        const t84Not1 = rb8 & rb4 & ~rb1;
        const tRMGM = t83Not4 & rb2 & rb8;
        const tNot841 = tRMGM & rb1 & rb4 & rb8 & ~binary;
        const tNum0 = b1 | b2 | b4 | b8;
        const t1622Bit0NotFlgGM = (code == 0b01111111 ? 0 : b0);
        const t1622Blank = (selector == 5 ? (code == 0b00010000 ? 1 : 0) : 0);
        const tInOutPlusSign = 0;                       // ?? 1711 ??

        // Read bus zone bits.
        const rb0 = (selector == 5 ? t1622Bit0NotFlgGM : b0) | tEndLinePT;
        const rbx = bx;
        const rbc = bc | t1622Blank | tInOutPlusSign;

        const tNCa = ((rbc & tCorrCBit) | (~rbc & ~tCorrCBit)) & ~t1622Blank;
        const tZ2a = (~rbx & tNum0 & ~rb0) & ~rbx & ~tRMGM & ~binary;
        const tSpecChar = (rb1 & rb2 & rb8) | t84Not1;
        const tCorrCBit = (~rb0 & rbx) | (rb0 & ~rbx);
        const tRdBus0RM = rb0 & tRMGM;                  // ??

        // Output numeric bits.
        const n1 = rb1 & tNot841;
        const n2 = rb2;
        const n4 = rb4 & tNot841;
        const n8 = ((rb8 & ~rb4 & ~rb2) | tRMGM | (rb8 & tNot841 & numeric)) & ~binary;
        const nc = ((tNCa & t84Not1 & alpha) | (tNCa numeric) | t841 | (alpha & t83Not4)) &
                        ~binary & (selector != 7);

        const ioFlag = rbx & (!tRMGM & !tNum0) & numeric;

        // Output zone bits.
        const z1 = ((rb0 & ~tNum0) & (tNum0 & ~rb0) & ~binary & ~tRMGM)) | bz1;
        const z2 = tZ2a | bz2 | (~binary & tNum0 & ~rb0 & rbx);
        const z4 = ((tNum0 & tZ2a) & ~tRdBus0RM & ~binary & ~b1 & ~tSpecChar & ~tRMGM) | bz4;
        const zc = (~((~tSpecChar & tCorrCBit) | (tSpecChar & ~tCorrCBit)) & ~b1 & ~tNum0) |
                        t1622Blank | tRdBus0RM | bz1;

        return [(((((((((nc << 1) | ioFlag) << 1) | n8) << 1) | n4) << 1) | n2) << 1) | n1,
                (((((((((zc << 1) |      0) << 1) | z8) << 1) | z4) << 1) | z2) << 1) | z1];
    }

    function formatXlate(row, zone, num) {
        /*  */
        let cell = document.createElement("td");
        cell.textContent = zone.toString(2).padStart(6, "0") + " " + num.toString(2).padStart(6, "0");
        cell.appendChild(cell);

        cell = document.createElement("td");
        cell.textContent = alphaGlyphs[(zone & bcdMask)*16 + (num & bcdMask)];
    }


    const body = document.getElementById("XlateBody");

    for (let code=0; code<256; ++code) {
        const row = document.createElement("tr");
        const rowNr = document.createElement("td");

       let [zone, num] = xlateIn(code, 3, 36);

        body.appendChild(row);
    }

    // Dump the add table results.
    const resultsPre = document.getElementById("AddResults");
    resultsPre.appendChild(document.createTextNode("const addTable = [\n"));
    for (let p=0; p<32; ++p) {
        let line = "    [";
        for (let q=0; q<32; ++q) {
            line += "0x" + sumTable[p][q].toString(16).padStart(2, "0") + ",";
        }

        resultsPre.appendChild(document.createTextNode(line.slice(0, -1) + "],\n"));
    }

    resultsPre.appendChild(document.createTextNode("];\n"));
}, {once: true});
</script>
</head>

<body>
<h2>Build Full Xlate Table</h2>
<table border=1 cellspacing=0 cellpadding=2>
    <thead>
        <tr>
            <th rowspan=2>Code
            <th colspan=5>PaperTape
            <th colspan=4>Card
        <tr>
            <th colspan=2>Numeric
            <th colspan=2>Alpha
            <th>Binary
            <th colspan=2>Numeric
            <th colspan=2>Alpha
    <tbody id=XlateBody>
</table>
<h2>Tranalator Table Results</h2>
<pre id=XlateResults></pre>

</body>
</html>